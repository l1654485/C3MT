import os
import cv2
import torch
import random
import math
import numpy as np
from glob import glob
from torch.utils.data import Dataset
import h5py
from scipy.ndimage.interpolation import zoom
from torchvision import transforms
import itertools
from scipy import ndimage
from torch.utils.data.sampler import Sampler
import augmentations
from augmentations.ctaugment import OPS
import matplotlib.pyplot as plt
from PIL import Image
from copy import deepcopy
import gridmask
import pdb
import torch.nn as nn


class BaseDataSets(Dataset):
    def __init__(
        self,
        base_dir=None,
        split="train",
        num=None,
        transform=None,
        ops_weak=None,
        ops_strong=None,
    ):
        self._base_dir = base_dir#路径
        self.sample_list = []
        self.split = split#分割类型
        self.transform = transform#图像处理
        self.ops_weak = ops_weak#弱增强
        self.ops_strong = ops_strong#强增强

        assert bool(ops_weak) == bool(
            ops_strong
        ), ("For using CTAugment learned policies, provide both weak and strong batch augmentation policy")#对于使用CTAugment学习策略，提供弱和强批量增强策略

        if self.split == "train":
            with open(self._base_dir + "/train_slices.list", "r") as f1:#读取训练分割列表
                self.sample_list = f1.readlines()
            self.sample_list = [item.replace("\n", "") for item in self.sample_list]

        elif self.split == "val":#验证集
            with open(self._base_dir + "/val.list", "r") as f:
                self.sample_list = f.readlines()
            self.sample_list = [item.replace("\n", "") for item in self.sample_list]
        if num is not None and self.split == "train":
            self.sample_list = self.sample_list[:num]
        print("total {} samples".format(len(self.sample_list)))

    def __len__(self):
        return len(self.sample_list)

    def __getitem__(self, idx):
        case = self.sample_list[idx]
        if self.split == "train":
            h5f = h5py.File(self._base_dir + "/data/slices/{}.h5".format(case), "r")
        else:
            h5f = h5py.File(self._base_dir + "/data/{}.h5".format(case), "r")
        image = h5f["image"][:]
        label = h5f["label"][:]
        sample = {"image": image, "label": label}
        if self.split == "train":
            if None not in (self.ops_weak, self.ops_strong):
                sample = self.transform(sample, self.ops_weak, self.ops_strong)
            else:
                sample = self.transform(sample)
        sample["idx"] = idx
        return sample


def random_rot_flip(image, label=None):#随机旋转翻转
    k = np.random.randint(0, 4)
    image = np.rot90(image, k)
    axis = np.random.randint(0, 2)
    image = np.flip(image, axis=axis).copy()
    if label is not None:
        label = np.rot90(label, k)
        label = np.flip(label, axis=axis).copy()
        return image, label
    else:
        return image


def random_rotate(image, label):#随机旋转
    angle = np.random.randint(-20, 20)
    image = ndimage.rotate(image, angle, order=0, reshape=False)
    label = ndimage.rotate(label, angle, order=0, reshape=False)
    return image, label


def color_jitter(image):#颜色抖动
    if not torch.is_tensor(image):
        np_to_tensor = transforms.ToTensor()
        image = np_to_tensor(image)

    # s is the strength of color distortion.
    s = 1.0
    jitter = transforms.ColorJitter(0.8 * s, 0.8 * s, 0.8 * s, 0.2 * s)#随机改变一个图像的亮度、对比度、饱和度和色调。
    return jitter(image)

def rand_affine(image):#随机仿射变换
    if not torch.is_tensor(image):
        np_to_tensor = transforms.ToTensor()
        image = np_to_tensor(image)

    affine = transforms.RandomAffine(degrees = 90,translate=(0.5,0.5),shear=30)#旋转角度、 平移区间、错切角度
    return affine(image)

def gaussian_blur(image):#高斯模糊
    if not torch.is_tensor(image):
        np_to_tensor = transforms.ToTensor()
        image = np_to_tensor(image)

    blur = transforms.GaussianBlur(3)
    return blur(image)

def rand_gray(image):
    if not torch.is_tensor(image):
        np_to_tensor = transforms.ToTensor()
        image = np_to_tensor(image)

    gray = transforms.RandomGrayscale(p=0.2)
    return gray(image)

# def rand_gray(image):#随机灰度
#     if not torch.is_tensor(image):
#         np_to_tensor = transforms.ToTensor()
#         image = np_to_tensor(image)
#
#     if image.size(0) == 1: # Check if the image has only 1 channel
#         image = torch.cat((image, image, image), 0) # Convert to 3-channel image by duplicating the channel
#
#     gray = transforms.RandomGrayscale(p=0.2)
#     return gray(image)



def grid_mask(image):#空洞擦除
    if not torch.is_tensor(image):
        np_to_tensor = transforms.ToTensor()
        image = np_to_tensor(image)
    mask = gridmask.Gridmask()
    return mask(image)


class CTATransform(object):#cta增强
    def __init__(self, output_size, cta):
        self.output_size = output_size
        self.cta = cta

    def __call__(self, sample, ops_weak, ops_strong):
        image, label = sample["image"], sample["label"]
        image = self.resize(image)#调整尺寸
        label = self.resize(label)
        to_tensor = transforms.ToTensor()

        # fix dimensions固定尺寸
        image = torch.from_numpy(image.astype(np.float32)).unsqueeze(0)
        label = torch.from_numpy(label.astype(np.uint8))

        # apply augmentations应用增强
        image_weak = augmentations.cta_apply(transforms.ToPILImage()(image), ops_weak)
        image_strong = augmentations.cta_apply(image_weak, ops_strong)
        label_aug = augmentations.cta_apply(transforms.ToPILImage()(label), ops_weak)
        label_aug = to_tensor(label_aug).squeeze(0)
        label_aug = torch.round(255 * label_aug).int()

        sample = {
            "image": image,
            "image_weak": to_tensor(image_weak),
            "image_strong": to_tensor(image_strong),
            "label_aug": label_aug,
            "label": label
        }
        return sample

    def cta_apply(self, pil_img, ops):
        if ops is None:
            return pil_img
        for op, args in ops:
            pil_img = OPS[op].f(pil_img, *args)
        return pil_img

    def resize(self, image):
        x, y = image.shape
        return zoom(image, (self.output_size[0] / x, self.output_size[1] / y), order=0)



    
class RandomGenerator_w(object):#随机弱增强
    def __init__(self, output_size):
        self.output_size = output_size

    def __call__(self, sample):
        image, label = sample["image"], sample["label"]
        x1, y1 = image.shape
        x2, y2 = label.shape
        #调整大小并转换为张量
        image = zoom(image, (self.output_size[0] / x1, self.output_size[1] / y1), order=0)
        label = zoom(label, (self.output_size[0] / x2, self.output_size[1] / y2), order=0)
        image = torch.from_numpy(image.astype(np.float32)).unsqueeze(0)
        label = torch.from_numpy(label.astype(np.uint8))
        sample = {"image": image, "label": label}
        return sample


# class WeakStrongAugment(object):#弱增强和强增强
#     """returns weakly and strongly augmented images
#
#     Args:
#         object (tuple): output size of network
#     """
#
#     def __init__(self, output_size):
#         self.output_size = output_size
#
#     def __call__(self, sample):
#         image, label = sample["image"], sample["label"]
#         image = self.resize(image)
#         label = self.resize(label)
#         # weak augmentation is rotation / flip弱增强是旋转/翻转
#         image_weak, label = random_rot_flip(image, label)
#         # strong augmentation is color jitter强烈的增强是颜色抖动
#         image_strong = color_jitter(image_weak).type("torch.FloatTensor")
#         # fix dimensions固定尺寸
#         image = torch.from_numpy(image.astype(np.float32)).unsqueeze(0)
#         image_weak = torch.from_numpy(image_weak.astype(np.float32)).unsqueeze(0)
#         label = torch.from_numpy(label.astype(np.uint8))
#
#         sample = {
#             "image": image,
#             "image_weak": image_weak,
#             "image_strong": image_strong,
#             "label_aug": label,
#         }
#         return sample
#
#     def resize(self, image):
#         x, y = image.shape
#         return zoom(image, (self.output_size[0] / x, self.output_size[1] / y), order=0)


class TwoStreamBatchSampler(Sampler):
    """Iterate two sets of indices迭代两组索引

    An 'epoch' is one iteration through the primary indices.
    During the epoch, the secondary indices are iterated through
    as many times as needed.
    """

    def __init__(self, primary_indices, secondary_indices, batch_size, secondary_batch_size):
        self.primary_indices = primary_indices
        self.secondary_indices = secondary_indices
        self.secondary_batch_size = secondary_batch_size
        self.primary_batch_size = batch_size - secondary_batch_size
        assert len(self.primary_indices) >= self.primary_batch_size > 0
        assert len(self.secondary_indices) >= self.secondary_batch_size > 0

    def __iter__(self):
        primary_iter = iterate_once(self.primary_indices)#随机排列
        secondary_iter = iterate_eternally(self.secondary_indices)
        return (
            primary_batch + secondary_batch
            for (primary_batch, secondary_batch) in zip(
                grouper(primary_iter, self.primary_batch_size),
                grouper(secondary_iter, self.secondary_batch_size),
            )
        )

    def __len__(self):
        return len(self.primary_indices) // self.primary_batch_size


def iterate_once(iterable):
    return np.random.permutation(iterable)


def iterate_eternally(indices):
    def infinite_shuffles():
        while True:
            yield np.random.permutation(indices)

    return itertools.chain.from_iterable(infinite_shuffles())


def grouper(iterable, n):
    "Collect data into fixed-length chunks or blocks将数据收集到固定长度的块中"
    # grouper('ABCDEFG', 3) --> ABC DEF"
    args = [iter(iterable)] * n
    return zip(*args)

class Grid(object):
    def __init__(self, d1, d2, rotate=1, ratio=0.5, mode=0, prob=1.):
        self.d1 = d1
        self.d2 = d2
        self.rotate = rotate
        self.ratio = ratio
        self.mode = mode
        self.st_prob = self.prob = prob
 
    def set_prob(self, epoch, max_epoch):
        self.prob = self.st_prob * min(1, epoch / max_epoch)
 
    def __call__(self, img):
        if np.random.rand() > self.prob:
            return img
        h = img.size(1)
        w = img.size(2)
 
        # 1.5 * h, 1.5 * w works fine with the squared images
        # But with rectangular input, the mask might not be able to recover back to the input image shape
        # A square mask with edge length equal to the diagnoal of the input image
        # will be able to cover all the image spot after the rotation. This is also the minimum square.
        hh = math.ceil((math.sqrt(h * h + w * w)))
 
        d = np.random.randint(self.d1, self.d2)
        # d = self.d
 
        # maybe use ceil? but i guess no big difference
        self.l = math.ceil(d * self.ratio)
 
        mask = np.ones((hh, hh), np.float32)
        st_h = np.random.randint(d)
        st_w = np.random.randint(d)
        for i in range(-1, hh // d + 1):
            s = d * i + st_h
            t = s + self.l
            s = max(min(s, hh), 0)
            t = max(min(t, hh), 0)
            mask[s:t, :] *= 0
 
        for i in range(-1, hh // d + 1):
            s = d * i + st_w
            t = s + self.l
            s = max(min(s, hh), 0)
            t = max(min(t, hh), 0)
            mask[:, s:t] *= 0
 
        r = np.random.randint(self.rotate)
        mask = Image.fromarray(np.uint8(mask))
        mask = mask.rotate(r)
        mask = np.asarray(mask)
        mask = mask[(hh - h) // 2:(hh - h) // 2 + h, (hh - w) // 2:(hh - w) // 2 + w]
 
        mask = torch.from_numpy(mask).float()
        if self.mode == 1:
            mask = 1 - mask
 
        mask = mask.expand_as(img)
        img = img * mask
 
        return img
 
class Grid_Mask(nn.Module):
    def __init__(self, d1=20, d2=80, rotate=90, ratio=0.4, mode=1, prob=0.8):
        super(Grid_Mask, self).__init__()
        self.rotate = rotate
        self.ratio = ratio
        self.mode = mode
        self.st_prob = prob
        self.grid = Grid(d1, d2, rotate, ratio, mode, prob)
 
    def set_prob(self, epoch, max_epoch):
        self.grid.set_prob(epoch, max_epoch)
 
    
    def forward(self, x):
        if not self.training:
            return x
        
        return self.grid(x)

class RandomGenerator_s(object):#强增强
    def __init__(self, output_size):
        self.output_size = output_size

    def __call__(self, sample):
        image, label = sample["image"], sample["label"]
        # ind = random.randrange(0, img.shape[0])
        # image = img[ind, ...]
        # label = lab[ind, ...]
        if random.random() > 0.5:
            image, label = random_rot_flip(image, label)
        elif random.random() > 0.5:
            image, label = random_rotate(image, label)
        x1, y1 = image.shape
        x2, y2 = label.shape
        image = zoom(image, (self.output_size[0] / x1, self.output_size[1] / y1), order=0)
        label = zoom(label, (self.output_size[0] / x2, self.output_size[1] / y2), order=0)
        image = color_jitter(image).type("torch.FloatTensor")
        image = rand_affine(image).type("torch.FloatTensor")
        image = gaussian_blur(image).type("torch.FloatTensor")
        image = rand_gray(image).type("torch.FloatTensor")
#         grid_mask = Grid_Mask()
#         image = grid_mask(image).type("torch.FloatTensor")
#         image = torch.from_numpy(image.astype(np.float32)).unsqueeze(0)
        label = torch.from_numpy(label.astype(np.uint8))
        
        sample = {"image": image, "label": label}
        return sample
    
    
class RandomGenerator(object):#随机增强器
    def __init__(self, output_size):
        self.output_size = output_size

    def __call__(self, sample):
        image, label = sample["image"], sample["label"]
        # ind = random.randrange(0, img.shape[0])
        # image = img[ind, ...]
        # label = lab[ind, ...]
        if random.random() > 0.5:
            image, label = random_rot_flip(image, label)
        elif random.random() > 0.5:
            image, label = random_rotate(image, label)
        x1, y1 = image.shape
        x2, y2 = label.shape
        image = zoom(image, (self.output_size[0] / x1, self.output_size[1] / y1), order=0)
        label = zoom(label, (self.output_size[0] / x2, self.output_size[1] / y2), order=0)
        image = torch.from_numpy(image.astype(np.float32)).unsqueeze(0)
        # image = transforms.Grayscale(num_output_channels=1)
        label = torch.from_numpy(label.astype(np.uint8))
        # print(label.size())
        sample = {"image": image, "label": label}
        return sample

class WeakStrongAugment(object):#弱增强和强增强
    """returns weakly and strongly augmented images

    Args:
        object (tuple): output size of network
    """

    def __init__(self, output_size):
        self.output_size = output_size

    def __call__(self, sample):
        image, label = sample["image"], sample["label"]
        image = self.resize(image)
        label = self.resize(label)
        image_weak = image
        if random.random() > 0.5:
            image_weak, label = random_rot_flip(image, label)
        elif random.random() > 0.5:
            image_weak, label = random_rotate(image, label)
        # strong augmentation is color jitter强烈的增强是颜色抖动
        image_strong = color_jitter(image_weak).type("torch.FloatTensor")
        image_strong = rand_affine(image_strong).type("torch.FloatTensor")
        image_strong = gaussian_blur(image_strong).type("torch.FloatTensor")
        image_strong = rand_gray(image_strong).type("torch.FloatTensor")
        # fix dimensions固定尺寸
        image = torch.from_numpy(image.astype(np.float32)).unsqueeze(0)
        image_weak = torch.from_numpy(image_weak.astype(np.float32)).unsqueeze(0)
        label = torch.from_numpy(label.astype(np.uint8))

        sample = {
            "image": image,
            "image_weak": image_weak,
            "image_strong": image_strong,
            "label_aug": label,
        }
        return sample

    def resize(self, image):
        x, y = image.shape
        return zoom(image, (self.output_size[0] / x, self.output_size[1] / y), order=0)
